#高级数据库管理
本文为 [django book](http://djangobook.com/advanced-database-management/)一书的翻译.

本章为Django中的关系型数据库提供了一些额外的信息, 同时也为连接遗留数据库提供了一些笔记,要点和窍门.

##一般性说明
Django视图为所有的数据库后端提供尽可能多的功能. 然而, 不是所有的数据库后端都是相似的, Django开发者不得不做一些设计方案,
以决定支持哪些功能, 保证哪些方式是安全的.

这个文档对Django一些功能的相关用法进行说明. 当然, 这个文档并不能取代特定的服务器文档或者参考手册.

###持久连接
持久连接避免了每次请求时都要重新建立一个连接的额外开销. **CONN_MAX_AGE** 参数决定了一次连接的最大生命周期. 因此,这个参数
控制着持久连接. 每个数据库都可以单独设置这个参数. **CONN_MAX_AGE** 参数的默认值为 0, 在每次请求结束时都会关闭数据库连接. 
想要能够持久连接, 把**CONN_MAX_AGE**参数设置为以秒为单位的正数即可. 想要无限期持久连接, 将它设置为 None.


###连接管理
第一次查询时, Django会打开一个通往数据库的连接. 在随后的请求中,它会保持连接是打开的,并且重复使用连接. 一旦超过**CONN_MAX_AGE**
参数所设置的最大生命周期的值, 或者不再请求后, Django将会关闭这个连接.

从细节上讲,无论Django是否需要一个或者已经失去一个连接, Django都会自动打开一个通往数据库的连接--要么因为这是第一次连接, 要么因为
之前的连接被关闭.

在每次请求的开始时, 如果它已经达到最大生命周期的值, Django会关闭连接. 如果你的数据库终端在连接一段时间后不再连接, 你应该将
**CONN_MAX_AGE**设置为一个更小的值, 以便Django不再试图使用一个应经被数据库服务器关闭的连接.(这个问题仅会影响业务量非常小
的站点.)

### 警告(Caveats)
当每个线程保持自我连接后, 你的数据库必须支持并发连接, 且其数量不能少于你现有工作线程数.

有时你的绝大多数视图都不能访问数据库, 例如因为这个数据库是外部系统的, 或者是由于缓存的原因. 在这些情况下, 你应该把**CONN_MAX_AGE**
的值设置的小一点, 甚至可以设置成0, 因为保持一个不可重复使用的连接是没有意义的. 这样做可以保持并发连接的值小一点.

开发服务器在处理每个请求时, 都会创建一个新的线程(thread), 从而使持久连接(persistent connection)无效. 在开发期间不要启动它们.

当Django建立通向数据库的链接时, 它会根据所使用的后端, 建立合适的参数. 如果你启动了持久链接, 这个设置在每次请求时便不再重复.如果你修改了参数,
比如链接隔离层(isolation level)或者时区(time zone), 你应该要么在每次请求的结束时恢复Django的默认值, 这样可以在每个请求的开始时强行设置(force)一个合适的值, 要么关闭持久链接(persistent connections).

## 编码(ENCODE)
Django假设所有的数据库都使用UTF-8编码. 使用其他的编码可能会造成不可预测的行为, 例如你的数据库的数据会发生值过长(value too long)错误, 这样数据
在Django中就是无效的.

## postgreSQL Notes
Django支持PostgreSQL 9.0或更高版本.

Django需要使用Psycopg2 2.0.9或更高版本.

### 优化PostgreSQL的配置
Django在数据库链接需要以下参数:

- `client_encoding : 'UTF8'`
- `default_transaction_isolation`: `'read committed'` 默认地, 或者在连接选项(connection options)中设置此值(见下面)
- `timezone: 'UTC'` 当`USE_TZ`为`True`时, 否则设置`TIME_ZONE`的值.

如果这些参数已经是正确的值, Django不会在每次新的链接设置他们, 这会稍许(slightly)提升性能(performance). 你可以直接在`postgresql.conf`
中设置它们, 或者更简便在每个数据库使用者(database user)中使用`ALTER ROLE`设置.

没有这些设置Django也会很好的工作, 但是每个新的链接会需要对设置这些参数做一些额外的查询.

###  隔离层(ISOLATION LEVEL)
就像PostgreSQL自身, Django默认`READ COMMITTED`为隔离层. 如果你需要更一个更高级别的隔离层,例如`REPEATABLE READ`
或者`SERIALIZABLE`, 在数据库配置文件中的`DATABASES`选项中的`OPITIONS`部分设置它:
```
import psycopg2.extensions

DATABASES = {
    # ...
    'OPTIONS': {
        'isolation_level': psycopg2.extensions.ISOLATION_LEVEL_SERIALIZABLE,
    },
}

```
在更高的隔离层之下, 你的应用应该做好处理准备, 来处理由序列化(serialization)失败引起的异常. 这个选项是为了高级用法
而设计的.

### 为VARCHAR和TEXT列索引
当在你的模型字段上指定`db_index=True`时, Django代表性地(typically)输出一个单独的`CREATE INDEX`语句. 然而, 如果
如果你的数据库字段类型是`carchar`或者`text`(通过`CharField`,`FileField`和`TextField`使用), 那么Django将会创建
一个额外的索引, 此索引为那个列(column)使用一个合适的PostgreSQL 类操作符(operator class). 在它们的SQL中, 要使用`LIKE` 
操作符来正确地执行查询(lookup), 那么额外的索引(index)就是必须的, 就如同使用`contains`和`startswith`查询类型来完成一样.

## MySQL Notes

### 支持版本
Django支持MySQL 5.5和更高的版本.

Django的`inspectdb`(检查数据库)功能使用`information_schema`(信息概要)数据库,  它包含了了所有数据库schemas(概要)的的细节数据.

Django希望数据库支持Unicode(UTF-8编码), 并且将强制事务处理(enforce transactions)任务和引用完整性任务(referential integerity)
委托给数据库. 当时用MyISAM储存引擎时, 后两种(two latter ones)(个人理解为前面所说的强制转换任务和引用完整性任务)是不会被MySQL强制(执行)的, 清楚地知道这个事实是很重要的.

### 储存引擎(storage engines)
MySQL有数种储存引擎. 你可以在数种配置(server configuration)中改变默认储存引擎.

直到MySQL 5.5.4, 默认引擎都是MyISAM. MyISAM的主要缺点(drawbacks)是它不支持事务处理(transactions)或者强制foreign-key约束(constraints).
从优点来说, 直到MySQL 5.6.4, 它是唯一支持full-text索引(indexing)和搜索的引擎.

自从MySQL 5.5.5, 默认的引擎是InnoDB. 这个引擎是完全事务性(fully transactional)的, 并且支持外键引用(foreign key references).
现在, 它可能是最好的选择. 然而, 注意在一个MySQL重启(restart)时, InnovativeDB自动增量(autoincrement)计数器会发生丢失现象. 这是因为它
不能记住`AUTO_INCREMENT`的值, 取而代之的是它作为`max(id)+1`重新创建. 这可能导致`AutoField`的值在无意间重复使用(reuse).

如果你将现存的项目升级到MySQL 5.5.5, 接着(subsequently)添加一些表(table), 清确保你的表(table)使用相同的储存引擎(也就是MyISAM或者InnoDB).
特别的, 如果一个表在它们之间有一个外键(ForeignKey), 并使用不同的储存引擎, 当运行`migrate`时, 你可能看见如下错误:
```
_mysql_exceptions.OperationalError: (
    1005, "Can't create table '\\db_name\\.#sql-4a8_ab' (errno: 150)"
)
```

