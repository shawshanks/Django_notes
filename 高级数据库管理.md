#高级数据库管理
本文为 [django book](http://djangobook.com/advanced-database-management/)一书的翻译.

本章为Django中的关系型数据库提供了一些额外的信息, 同时也为连接遗留数据库提供了一些笔记,要点和窍门.

##一般性说明
Django视图为所有的数据库后端提供尽可能多的功能. 然而, 不是所有的数据库后端都是相似的, Django开发者不得不做一些设计方案,
以决定支持哪些功能, 保证哪些方式是安全的.

这个文档对Django一些功能的相关用法进行说明. 当然, 这个文档并不能取代特定的服务器文档或者参考手册.

###持久连接
持久连接避免了每次请求时都要重新建立一个连接的额外开销. **CONN_MAX_AGE** 参数决定了一次连接的最大生命周期. 因此,这个参数
控制着持久连接. 每个数据库都可以单独设置这个参数. **CONN_MAX_AGE** 参数的默认值为 0, 在每次请求结束时都会关闭数据库连接. 
想要能够持久连接, 把**CONN_MAX_AGE**参数设置为以秒为单位的正数即可. 想要无限期持久连接, 将它设置为 None.


###连接管理
第一次查询时, Django会打开一个通往数据库的连接. 在随后的请求中,它会保持连接是打开的,并且重复使用连接. 一旦超过**CONN_MAX_AGE**
参数所设置的最大生命周期的值, 或者不再请求后, Django将会关闭这个连接.

从细节上讲,无论Django是否需要一个或者已经失去一个连接, Django都会自动打开一个通往数据库的连接--要么因为这是第一次连接, 要么因为
之前的连接被关闭.

在每次请求的开始时, 如果它已经达到最大生命周期的值, Django会关闭连接. 如果你的数据库终端在连接一段时间后不再连接, 你应该将
**CONN_MAX_AGE**设置为一个更小的值, 以便Django不再试图使用一个应经被数据库服务器关闭的连接.(这个问题仅会影响业务量非常小
的站点.)

### 警告(Caveats)
当每个线程保持自我连接后, 你的数据库必须支持并发连接, 且其数量不能少于你现有工作线程数.

有时你的绝大多数视图都不能访问数据库, 例如因为这个数据库是外部系统的, 或者是由于缓存的原因. 在这些情况下, 你应该把**CONN_MAX_AGE**
的值设置的小一点, 甚至可以设置成0, 因为保持一个不可重复使用的连接是没有意义的. 这样做可以保持并发连接的值小一点.

开发服务器在处理每个请求时, 都会创建一个新的线程(thread), 从而使持久连接(persistent connection)无效. 在开发期间不要启动它们.

当Django建立通向数据库的链接时, 它会根据所使用的后端, 建立合适的参数. 如果你启动了持久链接, 这个设置在每次请求时便不再重复.如果你修改了参数,
比如链接隔离层(isolation level)或者时区(time zone), 你应该要么在每次请求的结束时恢复Django的默认值, 这样可以在每个请求的开始时强行设置(force)一个合适的值, 要么关闭持久链接(persistent connections).

## 编码(ENCODE)
Django假设所有的数据库都使用UTF-8编码. 使用其他的编码可能会造成不可预测的行为, 例如你的数据库的数据会发生值过长(value too long)错误, 这样数据
在Django中就是无效的.

## postgreSQL Notes
Django支持PostgreSQL 9.0或更高版本.

Django需要使用Psycopg2 2.0.9或更高版本.

### 优化PostgreSQL的配置
Django在数据库链接需要以下参数:

- `client_encoding : 'UTF8'`
- `default_transaction_isolation`: `'read committed'` 默认地, 或者在连接选项(connection options)中设置此值(见下面)
- `timezone: 'UTC'` 当`USE_TZ`为`True`时, 否则设置`TIME_ZONE`的值.

如果这些参数已经是正确的值, Django不会在每次新的链接设置他们, 这会稍许(slightly)提升性能(performance). 你可以直接在`postgresql.conf`
中设置它们, 或者更简便在每个数据库使用者(database user)中使用`ALTER ROLE`设置.

没有这些设置Django也会很好的工作, 但是每个新的链接会需要对设置这些参数做一些额外的查询.

###  隔离层(ISOLATION LEVEL)
就像PostgreSQL自身, Django默认`READ COMMITTED`为隔离层. 如果你需要更一个更高级别的隔离层,例如`REPEATABLE READ`
或者`SERIALIZABLE`, 在数据库配置文件中的`DATABASES`选项中的`OPITIONS`部分设置它:
```
import psycopg2.extensions

DATABASES = {
    # ...
    'OPTIONS': {
        'isolation_level': psycopg2.extensions.ISOLATION_LEVEL_SERIALIZABLE,
    },
}

```
在更高的隔离层之下, 你的应用应该做好处理准备, 来处理由序列化(serialization)失败引起的异常. 这个选项是为了高级用法
而设计的.

### 为VARCHAR和TEXT列索引
当在你的模型字段上指定`db_index=True`时, Django代表性地(typically)输出一个单独的`CREATE INDEX`语句. 然而, 如果
如果你的数据库字段类型是`carchar`或者`text`(通过`CharField`,`FileField`和`TextField`使用), 那么Django将会创建
一个额外的索引, 此索引为那个列(column)使用一个合适的PostgreSQL 类操作符(operator class). 在它们的SQL中, 要使用`LIKE` 
操作符来正确地执行查询(lookup), 那么额外的索引(index)就是必须的, 就如同使用`contains`和`startswith`查询类型来完成一样.

## MySQL Notes

### 支持版本
Django支持MySQL 5.5和更高的版本.

Django的`inspectdb`(检查数据库)功能使用`information_schema`(信息概要)数据库,  它包含了了所有数据库schemas(概要)的的细节数据.

Django希望数据库支持Unicode(UTF-8编码), 并且将强制事务处理(enforce transactions)任务和引用完整性任务(referential integerity)
委托给数据库. 当时用MyISAM储存引擎时, 后两种(two latter ones)(个人理解为前面所说的强制转换任务和引用完整性任务)是不会被MySQL强制(执行)的, 清楚地知道这个事实是很重要的.

### 储存引擎(storage engines)
MySQL有数种储存引擎. 你可以在数种配置(server configuration)中改变默认储存引擎.

直到MySQL 5.5.4, 默认引擎都是MyISAM. MyISAM的主要缺点(drawbacks)是它不支持事务处理(transactions)或者强制foreign-key约束(constraints).
从优点来说, 直到MySQL 5.6.4, 它是唯一支持full-text索引(indexing)和搜索的引擎.

自从MySQL 5.5.5, 默认的引擎是InnoDB. 这个引擎是完全事务性(fully transactional)的, 并且支持外键引用(foreign key references).
现在, 它可能是最好的选择. 然而, 注意在一个MySQL重启(restart)时, InnovativeDB自动增量(autoincrement)计数器会发生丢失现象. 这是因为它
不能记住`AUTO_INCREMENT`的值, 取而代之的是它作为`max(id)+1`重新创建. 这可能导致`AutoField`的值在无意间重复使用(reuse).

如果你将现存的项目升级到MySQL 5.5.5, 接着(subsequently)添加一些表(table), 清确保你的表(table)使用相同的储存引擎(也就是MyISAM或者InnoDB).
特别的, 如果一个表在它们之间有一个外键(ForeignKey), 并使用不同的储存引擎, 当运行`migrate`时, 你可能看见如下错误:
```
_mysql_exceptions.OperationalError: (
    1005, "Can't create table '\\db_name\\.#sql-4a8_ab' (errno: 150)"
)
```
### MySQL数据库应用接口(API)驱动
Python数据库API在PEP249中有说明. MySQL有三种突出的(prominent)驱动来实现这个API:

- `MySQLdb`是一个自带的(native)驱动, 它由Andy Dustman开发, 并且支持时间超过了十年.
- `mysqlclient`是`MySQLdb`的一个分支, 它对Python3支持的非常好(notably), 对MySQLdb来说, 它是插入式(drop-in)的替代选择. 在这本书
   的创作期间, 如果你在Django中使用MySQL, 那么推荐你使用它.
- `MySQL Connector/Python`来自Oracle, 它是一个纯python驱动--它不需要MySQL客户端库(client library)或者任何Python标准库之外的模块.

所有这些驱动都是安全线程(thread-safe),并且提供连接池(connection pooling).
在当前, `MySQLdb`是唯一一个不支持Python3的驱动.

除了一个DB API(数据库应用接口)驱动之外, Django还需要一个适配器来从ORM(对象关系映射)访问数据库驱动. 虽然MySql Connector/python
已经包含了自身, Django还是为MySQLdb/mysqlclient提供了一个适配器. 

### mySQLdb
Django需要MySQLdb 的版本为1.2.1p2或者更高.

当你尝试使用Django时, 如果你看见`ImportError: cannot import name ImmutableSet`  , 你的MySQLdb安装(文件)中可能包含了一个过期的
`sets.py`文件, 由此和python2.4及以上版本的拥有相同名字内置模块造成了冲突. 为了改正它, 请确认你所安装的MySQLdb版本是1.2.1p2或者更高,
然后在MySQLdb目录中删除由更早版本遗留下来的`sets.py`文件.

同样还有广为人知的问题, MySQLdb将日期字符串(date strings)转换成时间对象(datetime objects). 特别的, 在MySQL中,日期字符串`0000-00-00`
是合法的, 但是却会被MySQLdb转换成`None`.

这意味着你在使用可能有`0000-00-00`的值的行(rows)来loaddata/dumpdata(载入数据)时, 要特别小心, 因为他们可能被转换成None.

在这本书的写作期间, 最新版本的MySQLdb(1.2.4)并不支持Python3. 为了在Python3中使用MySQLdb, 你只能安装`mysqlclient`.

### mySQLcilent
Django需要mysqlclient 1.3.3或者更高版本.
注意它并不支持Python3.2. 跟MySQLbd相比, 它除了支持Python 3.3+版本之外, 其他行为都应该是相同的.

### mySQL Connector/Python
MySQL Connector/Python 在下载页面是可用的. Django适配器在1.1.X或者更高版本是可用的. 他可能不支持最近的Django发布版本.

### 时区定义
如果你打算使用Django的时区支持, 使用`mysql_tzinfo_to_sql`来将时区表(time zone tables)载入MySQL数据库. 你只需对你的MySQL服务器
进行上述设置就行, 不用队每个数据库都进行设置.

### 创建你的数据库
你可以使用命令行工具和下述SQL语句来创建你的数据库:
```
CREATE DATABASE <dbname> CHARACTER SET utf8;
```
这么做将会确保所有的的表和列都默认使用UTF-8编码.

### 排序规则(collation)设置
排序规则设置是为了让一个列(a column)控制其数据排序顺序和字符串平等比较后的顺序. 可以在数据库范围(database-wide)层次, 每个表(per-table)
层次,和每个列(per column)层次上设置它. 在MySQL文档中全面地(thoroughly)记载了排序规则设置. 在所有的情况中, 你可以直接对数据库表进行操作
(manipulate)来进行排序设置;  Django没有提供在模型定义上的设置方法.

默认地, 使用一个UTF-8数据库,MySQL将会使用`utf8_general_ci`排序规则. 这导致了所有的字符串都以不区分大小写(case-insensitive)行为来进行相等性比较(equality comparisions). 也就是说, `'Fred'`和`'freD'`在数据库层面上被认为是相等的. 如果你在一个字段上有一个唯一约束(unique constraint),
尝试将`'aa'`和`'AA'`写进同一列是非法的, 这是因为他们使用默认的排序规则来使用比较其相等性.

在很多情况中, 默认行为没有问题. 然而, 如果你想在一个特别的列或表中来进行区分大小写(case-sensitve)比较, 你需要使用`utf8_bin`来改变列或表.在这种
情况下, 需要注意的主要的事情就是, 如果你使用MySQLdb 1.2.2, Django中的数据库后端在从数据库检索后, 返回的所有字符串类型都是字节字符串(bytestrings),而不是Unicode字符串. Django在正常情况下返回的一直是Unicode字符串, 因此这是一个非常剧烈的变化.

返回的字符串的形式取决于开发者, 如果你需要返回的字符串是bytestrings, 那么可以设置你的表为`urf8_bin`排序规则. 使用这些列(such column),Django自身工作应该很顺畅(除了下面所述的表`contrib.sessions Session`和`contrib.admin LogEntry`), 但是有时它真的想要使用一致的数据(consistant data), 那么你敲代码时应该准备调用`django.utils.encoding.smart_text()` -- Django不会为你做这些工作(数据库后端层和模型填充层在内部是分离的,
因此数据库层不知道它在特殊情况下需要创建这个协议(conversion)).



