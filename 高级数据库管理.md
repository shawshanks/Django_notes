#高级数据库管理
本文为 [django book](http://djangobook.com/advanced-database-management/)一书的翻译.

本章为Django中的关系型数据库提供了一些额外的信息, 同时也为连接遗留数据库提供了一些笔记,要点和窍门.

##一般性说明
Django视图为所有的数据库后端提供尽可能多的功能. 然而, 不是所有的数据库后端都是相似的, Django开发者不得不做一些设计方案,
以决定支持哪些功能, 保证哪些方式是安全的.

这个文档对Django一些功能的相关用法进行说明. 当然, 这个文档并不能取代特定的服务器文档或者参考手册.

###持久连接
持久连接避免了每次请求时都要重新建立一个连接的额外开销. **CONN_MAX_AGE** 参数决定了一次连接的最大生命周期. 因此,这个参数
控制着持久连接. 每个数据库都可以单独设置这个参数. **CONN_MAX_AGE** 参数的默认值为 0, 在每次请求结束时都会关闭数据库连接. 
想要能够持久连接, 把**CONN_MAX_AGE**参数设置为以秒为单位的正数即可. 想要无限期持久连接, 将它设置为 None.


###连接管理
第一次查询时, Django会打开一个通往数据库的连接. 在随后的请求中,它会保持连接是打开的,并且重复使用连接. 一旦超过**CONN_MAX_AGE**
参数所设置的最大生命周期的值, 或者不再请求后, Django将会关闭这个连接.

从细节上讲,无论Django是否需要一个或者已经失去一个连接, Django都会自动打开一个通往数据库的连接--要么因为这是第一次连接, 要么因为
之前的连接被关闭.

在每次请求的开始时, 如果它已经达到最大生命周期的值, Django会关闭连接. 如果你的数据库终端在连接一段时间后不再连接, 你应该将
**CONN_MAX_AGE**设置为一个更小的值, 以便Django不再试图使用一个应经被数据库服务器关闭的连接.(这个问题仅会影响业务量非常小
的站点.)

### 警告(Caveats)
当每个线程保持自我连接后, 你的数据库必须支持并发连接, 且其数量不能少于你现有工作线程数.

有时你的绝大多数视图都不能访问数据库, 例如因为这个数据库是外部系统的, 或者是由于缓存的原因. 在这些情况下, 你应该把**CONN_MAX_AGE**
的值设置的小一点, 甚至可以设置成0, 因为保持一个不可重复使用的连接是没有意义的. 这样做可以保持并发连接的值小一点.

开发服务器在处理每个请求时, 都会创建一个新的线程(thread), 从而使持久连接(persistent connection)无效. 在开发期间不要启动它们.

当Django建立通向数据库的链接时, 它会根据所使用的后端, 建立合适的参数. 如果你启动了持久链接, 这个设置在每次请求时便不再重复.如果你修改了参数,
比如链接隔离层(isolation level)或者时区(time zone), 你应该要么在每次请求的结束时恢复Django的默认值, 这样可以在每个请求的开始时强行设置(force)一个合适的值, 要么关闭持久链接(persistent connections).

## 编码(ENCODE)
Django假设所有的数据库都使用UTF-8编码. 使用其他的编码可能会造成不可预测的行为, 例如你的数据库的数据会发生值过长(value too long)错误, 这样数据
在Django中就是无效的.

## postgreSQL Notes
Django支持PostgreSQL 9.0或更高版本.

Django需要使用Psycopg2 2.0.9或更高版本.

### 优化PostgreSQL的配置
Django在数据库链接需要以下参数:

- `client_encoding : 'UTF8'`
- `default_transaction_isolation`: `'read committed'` 默认地, 或者在连接选项(connection options)中设置此值(见下面)
- `timezone: 'UTC'` 当`USE_TZ`为`True`时, 否则设置`TIME_ZONE`的值.

如果这些参数已经是正确的值, Django不会在每次新的链接设置他们, 这会稍许(slightly)提升性能(performance). 你可以直接在`postgresql.conf`
中设置它们, 或者更简便在每个数据库使用者(database user)中使用`ALTER ROLE`设置.

没有这些设置Django也会很好的工作, 但是每个新的链接会需要对设置这些参数做一些额外的查询.

###  隔离层(ISOLATION LEVEL)
就像PostgreSQL自身, Django默认`READ COMMITTED`为隔离层. 如果你需要更一个更高级别的隔离层,例如`REPEATABLE READ`
或者`SERIALIZABLE`, 在数据库配置文件中的`DATABASES`选项中的`OPITIONS`部分设置它:
```
import psycopg2.extensions

DATABASES = {
    # ...
    'OPTIONS': {
        'isolation_level': psycopg2.extensions.ISOLATION_LEVEL_SERIALIZABLE,
    },
}

```

